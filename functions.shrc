# Common shell functions

# mkdir and cd
function gcd() { mkdir -p "$@" && eval cd "\"\$$#\"";}

function calc() { awk "BEGIN {print $* }"; }
function mx() { awk 'BEGIN{getline; mx=$1;} { if($1>mx){mx=$1;} } END{ print mx; }' -; }
function mn() { awk 'BEGIN{getline; mn=$1;} { if($1<mn){mn=$1;} } END{ print mn; }' -; }
function sm() { awk 'BEGIN{sm=0;} {sm+=$1;} END {print sm;}' -; }
function max() { if [ $# -eq 0 ]; then mx; else echo "$@" | tr ' ' '\n' | mx; fi }
function min() { if [ $# -eq 0 ]; then mn; else echo "$@" | tr ' ' '\n' | mn; fi }
function sum() { if [ $# -eq 0 ]; then sm; else echo "$@" | tr ' ' '\n' | sm; fi }
function errno() { grep -w $1 /usr/include/asm-generic/errno*.h ; }

# CVS remove
function crm() {
  for f in "$@"; do
    rm "$f"
    cvs remove "$f"
  done
}

# Generate cscope and ctags files
function ref() {
  ctags -R .
  cscope -b -R
}

# Extract most compressed files
# Copied from git://github.com/lzap/dancepill.git
function e() {
  for F in "$@"; do
    if [ -f "$F" ] ; then
      FT1=$(file -b --mime-type "$F" | grep -Eo '[[:alnum:]_-]+/[[:alnum:]_-]+')
      #FT1=$(file -bi "$F" | grep -Eo '[[:alnum:]_-]+/[[:alnum:]_-]+')
      #DIR="$F-e"
      dirnm=$(dirname $F)
      basnm=$(basename $F)
      DIR="${dirnm}/${basnm%%.*}"
      mkdir "$DIR" || exit 1
      pushd "$DIR"
      case $FT1 in
        "application/x-bzip2") tar xjf "../$F" || bunzip2 "../$F" ;;
        "application/x-gzip") tar xzf "../$F" || gunzip "../$F" ;;
        "application/x-xz") tar xJf "../$F" ;;
        "application/x-rar") unrar x "../$F" || rar x "../$F" ;;
        "application/x-arj") arj x "../$F" || 7za x "../$F" ;;
        "application/x-lha") lha x "../$F" || 7za x "../$F" ;;
        "application/x-cpio") cpio -i "../$F" ;;
        "application/x-tar") tar xf "../$F" || gunzip "../$F" ;;
        "application/x-zip") unzip "../$F" ;;
        "application/zip") unzip "../$F" ;;
        "application/x-7z-compressed") 7za x "../$F" ;;
        "application/x-7za-compressed") 7za x "../$F" ;;
        "application/octet-stream") unlzma "../$F" || 7za x "../$F" || uncompress "../$F" ;;
        *) echo "'../$F' ($FT1) cannot be extracted via e() bash function" ;;
      esac
      popd
      # expecting only one file
      if [ "$(\ls "$DIR" | wc -l)" == "1" ]; then
        mv -v "$DIR"/* . && rmdir "$DIR"
      fi
    else
      echo "'$F' is not a valid file"
    fi
  done
}

function vman() {
  vim -c "SuperMan $*"

  if [ "$?" != "0" ]; then
    echo "No manual entry for $*"
  fi
}

function mysource() {
  for source_file in "$@"; do
    [ -f "$source_file" ] && source "$source_file"
  done
}

function source_files() {
  local RC="$(basename $SHELL)rc"

  mysource ~/profile/alias.shrc

  # OS-specific
  mysource ~/profile/$(uname -s).shrc
  mysource ~/profile/$(uname -s).${RC}

  # host-specific bashrc
  mysource ~/profile/$(uname -n).shrc
  mysource ~/profile/$(uname -n).${RC}
}

function z() {
  echo ">>>> host: $(uname -n)"
  echo -e ">>>> dirs:\n$(dirs -v)"
  if [[ 'true' = $(git rev-parse --is-inside-work-tree 2>/dev/null) ]]; then
    echo ">>>> git branches:"
    git branch -a
  fi
}

# Adapted from: https://stackoverflow.com/questions/342969/how-do-i-get-bash-completion-to-work-with-aliases
# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias
# based on the command and the given arguments, if there is a
# completer for the command, and set the wrapper as the completer for
# the alias.
function my_alias_wrapper() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  let COMP_CWORD+=$num_alias_arguments
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}


# Set auto comp for alias:
#
#   auto_comp_alias alias1 alias2 alias3 ...
#
# To set auto comp for all aliases:
#
#   eval "$(alias -p | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/my_alias_wrapper \1 \2 '\''\3'\'' /')"
function auto_comp_alias() {
  while [[ $# > 0 ]]; do
    eval "$(alias $1 | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/my_alias_wrapper \1 \2 '\''\3'\'' /')"
    shift 1
  done
}

# vim: set filetype=shell shiftwidth=2 tabstop=2 softtabstop=2 expandtab
